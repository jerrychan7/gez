"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([["771"],{5550:function(e,s,n){n.r(s),n.d(s,{default:function(){return a}});var r=n(1549),d=n(6603);function i(e){let s=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",pre:"pre",code:"code",div:"div",ul:"ul",li:"li",h3:"h3"},(0,d.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(s.h1,{id:"通用约定",children:["通用约定",(0,r.jsx)(s.a,{className:"header-anchor","aria-hidden":"true",href:"#通用约定",children:"#"})]}),"\n",(0,r.jsxs)(s.h2,{id:"目录规范",children:["目录规范",(0,r.jsx)(s.a,{className:"header-anchor","aria-hidden":"true",href:"#目录规范",children:"#"})]}),"\n",(0,r.jsx)(s.p,{children:"这是一个约定，无法通过程序配置来修改。"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-txt",children:"root\n│─ dist                  # 编译输出目录。\n│  ├─ package.json       # 编译输出后的软件包配置。\n│  ├─ server             # 服务端编译输出。\n│  │  └─ manifest.json   # 编译清单输出，用于生成 importmap。\n│  ├─ node               # Node 服务器程序编译输出。\n│  ├─ client             # 客户端编译输出。\n│  │  ├─ versions        # 版本存储目录。\n│  │  │  └─ latest.tgz   # 将 dist 目录归档，对外提供软件包分发。\n│  │  └─ manifest.json   # 编译清单输出，用于生成 importmap。\n│  └─ src                # 使用 tsc 生成的文件类型。\n├─ src\n│  ├─ entry.server.ts    # 服务端应用程序入口。\n│  ├─ entry.client.ts    # 客户端应用程序入口。\n│  └─ entry.node.ts      # Node 服务器应用程序入口。\n├─ tsconfig.json         # TypeScript 配置。\n└─ package.json          # 软件包配置。\n"})}),"\n",(0,r.jsxs)(s.div,{className:"rspress-directive tip",children:[(0,r.jsx)(s.div,{className:"rspress-directive-title",children:"拓展知识"}),(0,r.jsxs)(s.div,{className:"rspress-directive-content",children:["\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"gez.name"})," 来源于 ",(0,r.jsx)(s.code,{children:"package.json"})," 的 ",(0,r.jsx)(s.code,{children:"name"})," 字段。"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"dist/package.json"})," 来源于根目录的 ",(0,r.jsx)(s.code,{children:"package.json"}),"。"]}),"\n",(0,r.jsxs)(s.li,{children:["设置 ",(0,r.jsx)(s.code,{children:"packs.enable"})," 为 ",(0,r.jsx)(s.code,{children:"true"})," 时，才会对 ",(0,r.jsx)(s.code,{children:"dist"})," 目录进行归档。"]}),"\n"]}),"\n"]})]}),"\n",(0,r.jsxs)(s.h2,{id:"缓存策略",children:["缓存策略",(0,r.jsx)(s.a,{className:"header-anchor","aria-hidden":"true",href:"#缓存策略",children:"#"})]}),"\n",(0,r.jsxs)(s.p,{children:["在构建生产代码时，可以设置强缓存部分的资源，总是以 ",(0,r.jsx)(s.code,{children:".final[ext]"})," 作为文件名生成规则。也就是说符合这个规则的文件，可以设置强缓存，否则应设置协商缓存。"]}),"\n",(0,r.jsxs)(s.h3,{id:"final-文件",children:[(0,r.jsx)(s.code,{children:"final"})," 文件",(0,r.jsx)(s.a,{className:"header-anchor","aria-hidden":"true",href:"#final-文件",children:"#"})]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-ts",children:"res.setHeader('cache-control', 'public, max-age=31536000, immutable')\n"})}),"\n",(0,r.jsxs)(s.h3,{id:"其它文件",children:["其它文件",(0,r.jsx)(s.a,{className:"header-anchor","aria-hidden":"true",href:"#其它文件",children:"#"})]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-ts",children:"res.setHeader('cache-control', 'no-cache')\n"})}),"\n",(0,r.jsxs)(s.div,{className:"rspress-directive tip",children:[(0,r.jsx)(s.div,{className:"rspress-directive-title",children:"小知识"}),(0,r.jsx)(s.div,{className:"rspress-directive-content",children:(0,r.jsxs)(s.p,{children:["使用了 ",(0,r.jsx)(s.code,{children:"gez.middleware"})," 中间件，就会默认帮你处理这个逻辑。在生产环境时，你可以自己来实现静态服务器来控制不同的缓存策略，对于你来说 ",(0,r.jsx)(s.code,{children:"gez.middleware"})," 是可选的。",(0,r.jsx)(s.a,{href:"https://github.com/dp-os/gez/blob/master/packages/core/src/middleware.ts",target:"_blank",rel:"noopener noreferrer",children:"点击这里"})," 可以参考实现。\n"]})})]}),"\n",(0,r.jsxs)(s.h2,{id:"node-experimental",children:["Node experimental",(0,r.jsx)(s.a,{className:"header-anchor","aria-hidden":"true",href:"#node-experimental",children:"#"})]}),"\n",(0,r.jsxs)(s.p,{children:["在开发时，",(0,r.jsx)(s.code,{children:"gez"})," 会启用一些 Node 实验性质的功能，来获得开发环境支持 ESM 热更新和 TypeScript 的原生支持。"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-bash",children:"node --experimental-vm-modules --experimental-import-meta-resolve --experimental-strip-types\n"})}),"\n",(0,r.jsx)(s.p,{children:"但是在生产环境中，我们完全不需要这些，你应该使用构建后的产物来运行程序。"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-bash",children:"NODE_ENV=production node dist/index.js\n"})}),"\n",(0,r.jsxs)(s.div,{className:"rspress-directive warning",children:[(0,r.jsx)(s.div,{className:"rspress-directive-title",children:"WARNING"}),(0,r.jsx)(s.div,{className:"rspress-directive-content",children:(0,r.jsxs)(s.p,{children:["如果你在生产环境中使用 ",(0,r.jsx)(s.code,{children:"gez start"})," 来启动你的应用程序，由于启用了 Node 实验性功能的原因，可能会给你的程序带来未知的风险，请始终使用 ",(0,r.jsx)(s.code,{children:"NODE_ENV=production node dist/index.js"})," 来启动。\n"]})})]})]})}function c(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:s}=Object.assign({},(0,d.ah)(),e.components);return s?(0,r.jsx)(s,{...e,children:(0,r.jsx)(i,{...e})}):i(e)}let a=c;c.__RSPRESS_PAGE_META={},c.__RSPRESS_PAGE_META["guide%2Fessentials%2Fstd.mdx"]={toc:[{text:"目录规范",id:"目录规范",depth:2},{text:"缓存策略",id:"缓存策略",depth:2},{text:"`final` 文件",id:"final-文件",depth:3},{text:"其它文件",id:"其它文件",depth:3},{text:"Node experimental",id:"node-experimental",depth:2}],title:"通用约定",frontmatter:{}}}}]);