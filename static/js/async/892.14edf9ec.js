"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([["892"],{7208:function(e,r,n){n.r(r),n.d(r,{default:function(){return a}});var s=n(1549),t=n(6603);function c(e){let r=Object.assign({h1:"h1",a:"a",p:"p",code:"code",h2:"h2",pre:"pre",h3:"h3",div:"div"},(0,t.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(r.h1,{id:"渲染上下文",children:["渲染上下文",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#渲染上下文",children:"#"})]}),"\n",(0,s.jsxs)(r.p,{children:["我们有 ",(0,s.jsx)(r.code,{children:"entry.node.ts"})," 和 ",(0,s.jsx)(r.code,{children:"entry.server.ts"})," 两个入口文件，",(0,s.jsx)(r.code,{children:"entry.node.ts"})," 负责创建服务器，来调用 ",(0,s.jsx)(r.code,{children:"entry.server.ts"})," 生成 HTML。为了简化 CSS 和 JS 的注入，于是提供了一个 ",(0,s.jsx)(r.code,{children:"RenderContext"})," 对象。"]}),"\n",(0,s.jsxs)(r.h2,{id:"基本传参",children:["基本传参",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#基本传参",children:"#"})]}),"\n",(0,s.jsxs)(r.p,{children:["在 ",(0,s.jsx)(r.code,{children:"entry.node.ts"})," 通常可以看到这样的代码，调用一个渲染函数，然后服务响应 HTML。"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-ts",meta:'title="entry.node.ts"',children:"const rc = await gez.render({\n    // 传入渲染的参数\n    params: {\n        url: req.url\n    }\n});\n// 响应 HTML 内容\nres.end(rc.html);\n"})}),"\n",(0,s.jsxs)(r.p,{children:["在 ",(0,s.jsx)(r.code,{children:"entry.server.ts"})," 接收到传入的参数，并且根据传入的参数来响应内容。"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-ts",meta:'title="entry.server.ts"',children:"import type { RenderContext } from '@gez/core';\n\nexport default async (rc: RenderContext) => {\n    // 传入的参数\n    console.log(rc.params);\n    // 提交模块依赖收集\n    await rc.commit();\n    // 响应内容\n    rc.html = `你好世界！`;\n}\n"})}),"\n",(0,s.jsxs)(r.h2,{id:"模块依赖收集",children:["模块依赖收集",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#模块依赖收集",children:"#"})]}),"\n",(0,s.jsx)(r.p,{children:"在 SSR 应用程序中，要处理注入渲染页面的 CSS 和 JS 文件，并不是一件简单的事情，当需要考虑多服务提供的模块时，这个问题将会变得更难。庆幸的是，Gez 提供了一个标准的实现方案，并且在 Vue 中提供了完整的实现。"}),"\n",(0,s.jsxs)(r.p,{children:["在构建阶段，Gez 会给服务端生成的每一个 JS 文件头部注入一个 ",(0,s.jsx)(r.code,{children:"import.meta.chunkName"})," 字段，该字段提供了一个 chunk 文件打包的入口源文件。"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-ts",meta:'title="[chunk].js"',children:'import.meta.chunkName= import.meta.chunkName ?? "ssr-vue2-remote@src/entry.ts";\n'})}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.code,{children:"ssr-vue2-remote"})," 是我们的服务名，",(0,s.jsx)(r.code,{children:"src/entry.ts"})," 是这个文件打包的第一个文件。"]}),"\n",(0,s.jsx)(r.p,{children:"例如："}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-ts",children:"import('ssr-vue2-remote/src/app.ts');\n"})}),"\n",(0,s.jsx)(r.p,{children:"上述代码，就会生成"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-ts",children:'import.meta.chunkName = import.meta.chunkName ?? "ssr-vue2-remote@src/app.ts";\n'})}),"\n",(0,s.jsxs)(r.h3,{id:"vue2-例子",children:["Vue2 例子",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#vue2-例子",children:"#"})]}),"\n",(0,s.jsxs)(r.p,{children:["将渲染上下文的 ",(0,s.jsx)(r.code,{children:"importMetaSet"})," 对象传递给 Vue SSR 渲染的上下文对象中。"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-ts",meta:'title="entry.server.ts"',children:"export default async (rc: RenderContext) => {\n    const { app } = createApp();\n\n    const html = await renderer.renderToString(app, {\n        importMetaSet: rc.importMetaSet\n    });\n    // ......\n};\n\n"})}),"\n",(0,s.jsx)(r.p,{children:"在 Vue 组件中，收集上下文依赖。"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-ts",meta:'title="App.vue"',children:"export default {\n    serverPrefetch () {\n        this.$ssrContext?.importMetaSet.add(import.meta);\n    }\n}\n"})}),"\n",(0,s.jsxs)(r.div,{className:"rspress-directive tip",children:[(0,s.jsx)(r.div,{className:"rspress-directive-title",children:"TIP"}),(0,s.jsx)(r.div,{className:"rspress-directive-content",children:(0,s.jsxs)(r.p,{children:["在实际的操作中，",(0,s.jsx)(r.code,{children:"@gez/rspack-vue"})," 已经在编译 ",(0,s.jsx)(r.code,{children:".vue"})," 组件时，已经将这段代码注入，你不需要手动调用。\n"]})})]}),"\n",(0,s.jsxs)(r.p,{children:["等 Vue 组件渲染完成后，调用 ",(0,s.jsx)(r.code,{children:"await rc.commit()"})," 函数来提交模块上下文的依赖收集， ",(0,s.jsx)(r.code,{children:"rc.preload()"}),"、",(0,s.jsx)(r.code,{children:"rc.css()"}),"、",(0,s.jsx)(r.code,{children:"rc.importmap()"}),"、",(0,s.jsx)(r.code,{children:"rc.modulePreload()"})," 才能正确的注入客户端所需的依赖。"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-ts",meta:'title="entry.server.ts"',children:"\nexport default async (rc: RenderContext) => {\n    // ......\n    await rc.commit();\n\n    rc.html = `\n<!DOCTYPE html>\n<html>\n<head>\n    ${rc.preload()}\n    <title>Gez</title>\n    ${rc.css()}\n</head>\n<body>\n    ${html}\n    ${rc.importmap()}\n    ${rc.moduleEntry()}\n    ${rc.modulePreload()}\n</body>\n</html>\n`;\n};\n\n"})}),"\n",(0,s.jsxs)(r.h2,{id:"深入了解",children:["深入了解",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#深入了解",children:"#"})]}),"\n",(0,s.jsxs)(r.div,{className:"rspress-directive tip",children:[(0,s.jsx)(r.div,{className:"rspress-directive-title",children:"TIP"}),(0,s.jsx)(r.div,{className:"rspress-directive-content",children:(0,s.jsxs)(r.p,{children:["如果你想更加深入了解模块依赖收集，可以看下 ",(0,s.jsx)(r.a,{href:"https://github.com/dp-os/gez/tree/master/examples/ssr-html",target:"_blank",rel:"noopener noreferrer",children:"ssr-html"})," 这个例子，它是通过编码的形式来实现模块的依赖收集。\n"]})})]})]})}function d(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:r}=Object.assign({},(0,t.ah)(),e.components);return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}let a=d;d.__RSPRESS_PAGE_META={},d.__RSPRESS_PAGE_META["guide%2Fessentials%2Frender-context.mdx"]={toc:[{text:"基本传参",id:"基本传参",depth:2},{text:"模块依赖收集",id:"模块依赖收集",depth:2},{text:"Vue2 例子",id:"vue2-例子",depth:3},{text:"深入了解",id:"深入了解",depth:2}],title:"渲染上下文",frontmatter:{}}}}]);